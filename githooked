#!/usr/bin/env bash
# This script was generated by bashly 1.1.4 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

version_command() {
  echo "$version"
}

githooked_usage() {
  if [[ -n $long_usage ]]; then
    printf "githooked - Manage git hooks across your project with cross-platform support and mobility. Comfortably integrates with git to allow custom scripting. Designed for Bash 4.0 or compatible. Compatible with Git SCM (Git for Windows).\n"
    echo

  else
    printf "githooked - Manage git hooks across your project with cross-platform support and mobility. Comfortably integrates with git to allow custom scripting. Designed for Bash 4.0 or compatible. Compatible with Git SCM (Git for Windows).\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  githooked [OPTIONS] COMMAND\n"
  printf "  githooked [COMMAND] --help | -h\n"
  printf "  githooked --version | -v\n"
  echo

  printf "%s\n" "Commands:"
  printf "  %s   Install githooked runtime on the current path. Requires './.git/' to be present.\n" "install "
  printf "  %s   Generate default githooked 'no-op' placeholder hooks.\n" "generate"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--trace, -t"
    printf "    Print additional information and details.\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    printf "%s\n" "Examples:"
    printf "  ./githooked --help\n"
    printf "  ./githooked install --help\n"
    printf "  ./githooked generate --help\n"
    printf "  ./githooked generate prepare-commit-msg pre-commit pre-push\n"
    printf "  ./githooked upgrade\n"
    echo

  fi
}

githooked_install_usage() {
  if [[ -n $long_usage ]]; then
    printf "githooked install - Install githooked runtime on the current path. Requires './.git/' to be present.\n"
    echo

  else
    printf "githooked install - Install githooked runtime on the current path. Requires './.git/' to be present.\n"
    echo

  fi

  printf "Alias: inst, i\n"
  echo

  printf "%s\n" "Usage:"
  printf "  githooked install\n"
  printf "  githooked install --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

githooked_generate_usage() {
  if [[ -n $long_usage ]]; then
    printf "githooked generate - Generate default githooked 'no-op' placeholder hooks.\n"
    echo

  else
    printf "githooked generate - Generate default githooked 'no-op' placeholder hooks.\n"
    echo

  fi

  printf "Alias: g\n"
  echo

  printf "%s\n" "Usage:"
  printf "  githooked generate HOOK...\n"
  printf "  githooked generate --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "HOOK..."
    printf "    https://git-scm.com/docs/githooks#_hooks\n"
    printf "    Allowed: applypatch-msg, pre-applypatch, post-applypatch, pre-commit, pre-merge-commit, prepare-commit-msg, commit-msg, post-commit, pre-rebase, post-checkout, post-merge, pre-push, pre-receive, update, proc-receive, post-receive, post-update, reference-transaction, push-to-checkout, pre-auto-gc, post-rewrite, sendemail-validate, fsmonitor-watchman, p4-changelist, p4-prepare-changelist, p4-post-changelist, p4-pre-submit, post-index-change\n"
    echo

  fi
}

normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}

inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

build_githooked() {
  cat <<'EOF' >$1
#!/usr/bin/env bash

if [ -z "$SKIP_GIT_HOOKED_INIT" ]; then
  # Initialize the Debug Logger.
  debug () {
    if [ "$HOOK_DEBUG" = "1" ]; then
      echo "git-hooked (debug) - $1"
    fi
  }
  # Initialize the Notice Logger.
  notice () {
    if [ "$HOOK_DISABLE_NOTICE" = "0" ]; then
      echo "git-hooked (notice) - $1"
    fi
  }

  # Set and State the Hook
  readonly hook_name="$(basename "$0")"
  debug "Calling '$hook_name' ..."

  if [ "$HOOK" = "0" ]; then
    debug "Skipping the hook due to the environment variable 'HOOK' being set to 0."
  fi

  # Configure the hook to skip this call on the
  readonly SKIP_GIT_HOOKED_INIT="1"
  export SKIP_GIT_HOOKED_INIT

  bash -e "$0" "$@"
  code="$?"

  if [ "$code" != "0" ]; then
    notice "The hook '$hook_name' exited with code '$code' (error)."
    notice "Please review the output above to resolve the error. Once resolved, please attempt the git operation again."
  fi

  exit "$code"
fi
EOF
}

build_hook() {
  if ! [ -f "$1" ]; then
    cat <<'EOF' >$1
#!/usr/bin/env bash

# Configure the hook with these options.
HOOK_DEBUG=0          # Set to 1 to enable debug mode. This will print additional output.
HOOK_DISABLE_NOTICE=0 # Set to 1 to disable the notice when the hook exits with an error code.

# Import the git-hooked wrapper to prepare the env and execute the script below.
. "$(dirname "$0")/_util/git-hooked.sh"

# Your script begins here.
# The last command to run, or explicit "exit" commands, will determine the status code to Git.

# Default Hook: Full List of Hooks at https://git-scm.com/docs/githooks#_hooks
exit 0 # NO OP. This quietly passes to prevent spam during configuration.

EOF
  else
    trace "build_hook: (exists) '$1'"
  fi
}

build_gitignore() {
  cat <<'EOF' >$1
*
EOF
}

default_hooks() {
  local DEFAULT_HOOKS=("prepare-commit-msg" "pre-commit" "pre-push")
  echo "${DEFAULT_HOOKS[@]}"
}

info() {
  echo "$(green_bold info) $1"
}

trace() {
  if [[ ! -z "${args[--trace]}" || "${args[--trace]}" -eq 1 ]]; then
    echo "$(blue_bold trace) $1"
  fi
}

error() {
  echo "$(red error) $1"
}

githooked_install_command() {
  info "Installing 'githooked' to the current path..."

  # Execute 'git rev-parse'.
  info "Validating that project is valid git tracking."
  trace "git rev-parse HEAD"
  GIT_REVPARSE_HASH=$(git rev-parse HEAD)
  GIT_REVPARSE_EXIT=$?

  # Fail out if non-zero exit code was found.
  if [ "$GIT_REVPARSE_EXIT" -gt 0 ]; then
    error "Failed to execute rev-parse. Exited with code '$GIT_REVPARSE_EXIT' instead of code '0'."
    error "Please ensure that 'git init' has been executed and at least one commit has been made. You can also review the above output from rev-parse."
    exit 1
  fi

  # Fail out if no hash was found.
  if [ -z "$GIT_REVPARSE_HASH" ]; then
    error "Failed to detect hash from rev-parse. Found '$GIT_REVPARSE_HASH'."
    error "Please ensure that 'git init' has been executed and at least one commit has been made. You can also review the above output from rev-parse."
    exit 1
  fi

  # Update './.git-hooks'.
  # Set the working state.
  PWD="$(pwd)"
  GIT_HOOKS="$PWD/.git-hooks"
  UTIL="$GIT_HOOKS/_util"

  # Progress update.
  info "Generating '$GIT_HOOKS'."

  # Ensure file path(s) exist recursively.
  trace "mkdir -p '$UTIL'"
  mkdir -p "$UTIL"

  # Upsert '$UTIL/.gitignore'.
  trace "build_gitignore: '$UTIL/.gitignore'"
  build_gitignore "$UTIL/.gitignore"

  # Upsert '$UTIL/git-hooked.sh'.
  trace "build_githooked: '$UTIL/git-hooked.sh'"
  build_githooked "$UTIL/git-hooked.sh"

  # Check if any hooks exist. If not, we will generate defaults.
  if [ -z "$(ls -A ./.git-hooks/ | grep -v _util)" ]; then
    info "Generating default hooks."
    for HOOK in $(default_hooks); do
      trace "build_hook: '$HOOK'"
      build_hook "$GIT_HOOKS/$HOOK"
    done
  fi

  # Update permissions and set to execute.
  info "Setting file permissions for hooks."
  for HOOK in $(ls -A ./.git-hooks/ | grep -v _util); do
    trace "chmod 755 (+x) '$GIT_HOOKS/$HOOK'."
    chmod 755 "$GIT_HOOKS/$HOOK"
    chmod +x "$GIT_HOOKS/$HOOK"
  done

  # Set 'core.hooksPath' to './.git-hooks'.
  info "Setting 'core.hooksPath' to './.git-hooks'."
  trace "git config core.hooksPath './.git-hooks/'"
  git config core.hooksPath "./.git-hooks/"

}

githooked_generate_command() {
  info "Preparing to generate selected hooks."

  # Update './.git-hooks'.
  # Set the working state.
  PWD="$(pwd)"
  GIT_HOOKS="$PWD/.git-hooks"
  HOOKS="${args[hook]}"

  info "Generating selected hooks."
  for HOOK in $HOOKS; do
    HOOK=$(echo $HOOK | tr -d '"')
    trace "build_hook: '$GIT_HOOKS/$HOOK'"
    build_hook "$GIT_HOOKS/$HOOK"
  done

}

parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        githooked_usage
        exit
        ;;

      --trace | -t)

        args['--trace']=1
        shift
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v cat >/dev/null 2>&1; then
    deps['cat']="$(command -v cat | head -n1)"
  else
    printf "missing dependency: cat\n" >&2
    printf "%s\n" "Unable to locate 'cat'. githooked is only confirmed to be supported on Bash 4.0 or higher." >&2
    exit 1
  fi

  if command -v chmod >/dev/null 2>&1; then
    deps['chmod']="$(command -v chmod | head -n1)"
  else
    printf "missing dependency: chmod\n" >&2
    printf "%s\n" "Unable to locate 'chmod'. githooked is only confirmed to be supported on Bash 4.0 or higher." >&2
    exit 1
  fi

  if command -v dirname >/dev/null 2>&1; then
    deps['dirname']="$(command -v dirname | head -n1)"
  else
    printf "missing dependency: dirname\n" >&2
    printf "%s\n" "Unable to locate 'dirname'. githooked is only confirmed to be supported on Bash 4.0 or higher." >&2
    exit 1
  fi

  if command -v echo >/dev/null 2>&1; then
    deps['echo']="$(command -v echo | head -n1)"
  else
    printf "missing dependency: echo\n" >&2
    printf "%s\n" "Unable to locate 'echo'. githooked is only confirmed to be supported on Bash 4.0 or higher." >&2
    exit 1
  fi

  if command -v git >/dev/null 2>&1; then
    deps['git']="$(command -v git | head -n1)"
  else
    printf "missing dependency: git\n" >&2
    printf "%s\n" "Unable to locate 'git'. Please install git via your Package Manager. URL https://git-scm.com/" >&2
    exit 1
  fi

  if command -v ls >/dev/null 2>&1; then
    deps['ls']="$(command -v ls | head -n1)"
  else
    printf "missing dependency: ls\n" >&2
    printf "%s\n" "Unable to locate 'ls'. githooked is only confirmed to be supported on Bash 4.0 or higher." >&2
    exit 1
  fi

  if command -v mkdir >/dev/null 2>&1; then
    deps['mkdir']="$(command -v mkdir | head -n1)"
  else
    printf "missing dependency: mkdir\n" >&2
    printf "%s\n" "Unable to locate 'mkdir'. githooked is only confirmed to be supported on Bash 4.0 or higher." >&2
    exit 1
  fi

  if command -v pwd >/dev/null 2>&1; then
    deps['pwd']="$(command -v pwd | head -n1)"
  else
    printf "missing dependency: pwd\n" >&2
    printf "%s\n" "Unable to locate 'pwd'. githooked is only confirmed to be supported on Bash 4.0 or higher." >&2
    exit 1
  fi

  action=${1:-}

  case $action in
    -*) ;;

    install | inst | i)
      action="install"
      shift
      githooked_install_parse_requirements "$@"
      shift $#
      ;;

    generate | g)
      action="generate"
      shift
      githooked_generate_parse_requirements "$@"
      shift $#
      ;;

    "")
      githooked_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

githooked_install_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        githooked_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="install"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

githooked_generate_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        githooked_generate_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="generate"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['hook']+x} ]]; then
          args['hook']="\"$1\""
          shift
        else
          args['hook']="${args[hook]} \"$1\""
          shift
        fi

        ;;

    esac
  done

  if [[ -z ${args['hook']+x} ]]; then
    printf "missing required argument: HOOK\nusage: githooked generate HOOK...\n" >&2
    exit 1
  fi

  eval "input_array=(${args[hook]})"
  for i in "${input_array[@]}"; do
    if [[ ! $i =~ ^(applypatch-msg|pre-applypatch|post-applypatch|pre-commit|pre-merge-commit|prepare-commit-msg|commit-msg|post-commit|pre-rebase|post-checkout|post-merge|pre-push|pre-receive|update|proc-receive|post-receive|post-update|reference-transaction|push-to-checkout|pre-auto-gc|post-rewrite|sendemail-validate|fsmonitor-watchman|p4-changelist|p4-prepare-changelist|p4-post-changelist|p4-pre-submit|post-index-change)$ ]]; then
      printf "%s\n" "hook must be one of: applypatch-msg, pre-applypatch, post-applypatch, pre-commit, pre-merge-commit, prepare-commit-msg, commit-msg, post-commit, pre-rebase, post-checkout, post-merge, pre-push, pre-receive, update, proc-receive, post-receive, post-update, reference-transaction, push-to-checkout, pre-auto-gc, post-rewrite, sendemail-validate, fsmonitor-watchman, p4-changelist, p4-prepare-changelist, p4-post-changelist, p4-pre-submit, post-index-change" >&2
      exit 1
    fi
  done

}

initialize() {
  version="1.0.0-rc0"
  long_usage=''
  set -e

}

run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "install") githooked_install_command ;;
    "generate") githooked_generate_command ;;
  esac
}

initialize
run "$@"
